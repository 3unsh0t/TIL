/*
  2중 루프도 안되고(시간초가됨) 아무것도 안돼서 규칙을 찾아봤다.
  처음에 짝수 홀수 값을 미리 계산해두고,
  어차피 i는 0에서부터 1씩 증가하니깐
  i가 1씩 증가할때마다 이미 계산해둔
  pair과 odd가 어떻게 변하는지 규칙을 살펴봤다.

  그 결과

  i가 1증가하면,
  일단 i가 짝수인지 홀수인지 판단해서 계산해둔 pair과 odd에서 nums[i] 값을 뺀다.
  (이건 제외되는 값이니깐)
  사실 짝홀은 계속 왔다 갔다 하는 거니깐 의미에 집중하지말고 두가지로 나눈것에 집중했다.

  즉, i가 증가하면, i-1인덱스의 값 또한 더해진다. 이게 어디에 더해지는지는 아래의 코드를 참고...
  i가 짝수이면 i-1의(이전에 제외되었던 값)은 원래였으면 홀수였겠지만 i 다음에 있는요소들(pair과odd)는 뒤집어지므로 
  그대로 짝수에 i-1의 값을 더한다. 뭔소린지 잘 이해가 안되긴하는데 코드를 그렇게 고치니까 잘 돌아간다 ㅋ

  이렇게 해서 2중 루프를 쓰지않고 해결.
  시간 복잡도는 O(n)

  결과적으로 이 알고리즘은 이전에 썼던 값을 계속해서 사용하므로 상향식 알고리즘이고
  동적계획법을 사용한 것이다.
*/

class Solution {
    public int waysToMakeFair(int[] nums) {
        int result = 0;
        int pair = 0; //짝
        int odd = 0; //홀

        for(int i=0; i<nums.length; i+=2){
            pair += nums[i];
        }
        for(int j=1; j<nums.length; j+=2){
            odd += nums[j];
        }
        for(int i = 0; i<nums.length;i++){
            if(i%2==0){
                pair-= nums[i];
                if(i>0) pair+=nums[i-1];
            }else{
                odd-= nums[i];
                if(i>0) odd+=nums[i-1];
            }
            if(pair == odd){
                result++;
            }
        }
        return result;
    }
}
